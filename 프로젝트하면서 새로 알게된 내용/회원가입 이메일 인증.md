# 기본흐름
# 1. **회원가입**
   ## 1. token 생성 (임시 기간 동안 인증에 사용)
   ## 2. user 정보 **암호화**
# 2. 암호화된 정보를 **인증 메일**에 담아 보냄
# 3. **사용자가** 메일 확인하고, **인증 링크 접속**
# 4. **암호 풀어서**, 사용자 찾아내고, **인증**해주고, 자동 로그인 완료
# 5. 네이버 SMTP 서버 설정
## 메일 전송을 구현하기 위해 네이버 메일로 들어가 SMTP 서버를 설정합니다.

## *Google 또한 SMTP 서버를 제공하지만 Gmail 보안상의 이유로 렌더링하는 메일 html스타일에 href 경로가 존재하면 3~4분의 딜레이가 생기게 됩니다. 이 프로젝트에서는 토큰값이 담긴 href를 메일로 보내 인증하는 방식이기에 딜레이가 발생하는 Google SMTP를 사용하지 않고 Naver SMTP를 사용합니다.

## 네이버 메일의 환경설정에서 POP3/IMAP 설정으로 들어가 IMAP/SMTP 사용설정을 사용함으로 변경합니다.

## settings.py에 아래의 소스를 입력합니다.
```
# cs_web/settings.py

EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'smtp.naver.com'
EMAIL_HOST_USER = '<네이버 ID>'
EMAIL_HOST_PASSWORD = get_secret("EMAIL_HOST_PASSWORD")
EMAIL_USE_TLS = True
EMAIL_PORT = 587
DEFAULT_FROM_MAIL = '<네이버 ID>'
```
## EMAIL_HOST_PASSWORD를 숨기기 위해 SECRET_KEY값이 담긴 secrets.json파일에 naver 계정 비밀번호를 추가합니다.
```
# secrets.json

{
    "SECRET_KEY": "<SECRET_KEY 값">,
    "EMAIL_HOST_PASSWORD": "<네이버 계정 비밀번호>"
}
```
# 6. send_mail 구현
## Host 연결을 마쳤으므로 이제 django의 mail 기능인 send_mail을 import 하고 threading 모듈을 사용해 메일 보내기 기능을 구현합니다. 부가적인 기능을 따로 관리하기 위해 users app에 hepler.py를 생성하고 아래의 소스를 입력합니다.

```
# users/helper.py

from django.core.mail import send_mail
from django.core.mail import EmailMultiAlternatives
import threading

class EmailThread(threading.Thread):
    def __init__(self, subject, body, from_email, recipient_list, fail_silently, html):
        self.subject = subject
        self.body = body
        self.recipient_list = recipient_list
        self.from_email = from_email
        self.fail_silently = fail_silently
        self.html = html
        threading.Thread.__init__(self)

    def run (self):
        msg = EmailMultiAlternatives(self.subject, self.body, self.from_email, self.recipient_list)
        if self.html:
            msg.attach_alternative(self.html, "text/html")
        msg.send(self.fail_silently)

def send_mail(subject, recipient_list, body='', from_email='<네이버 메일계정>', fail_silently=False, html=None, *args, **kwargs):
    EmailThread(subject, body, from_email, recipient_list, fail_silently, html).start()
```

## threading 모듈을 사용해 동시에 여러 사용자에게 메일을 보낼 수 있도록 구현합니다. 또한 html 형식의 메일을 전송하기에 EmailMultiAlternatives를 import 하여 텍스트 뿐 아니라 다른 컨텐츠 유형을 포함시킬 수 있도록 합니다.


# 7. forms.py 수정
## 회원가입 후 메일 인증을 완료하지 못한 사용자는 로그인 할 수 없도록 앞서 구현한 forms.py에서 CsRegisterForm의 save함수에 is_active를 비활성화하는 소스를 추가합니다.
```
# users/forms.py

def save(self, commit=True):
    user = super(CsRegisterForm, self).save(commit=False)
    user.level = '2'
    user.department = '컴퓨터공학부'
    user.is_active = False
    user.save()
```